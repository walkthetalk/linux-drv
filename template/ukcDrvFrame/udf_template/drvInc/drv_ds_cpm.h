/*
 * driver main data structure definition and some interfaces' declearation,
 * they will be used by *UDF*
 */
#pragma once
/*
 * NOTE:
 * TODO:
 * please check this file's name, and *UDF_DRV_DS_HDR_FILE_NAME* in
 * your cfg file, they must be same.
 */

/*
 * include the op_set definition for bh part operation. e.g. read32/
 * write32/...
 */
#include "kdrv_op_set.h"

#ifdef __cplusplus
extern "C" {
#endif

// TODO: include your own header files if follow data structure need.


/*
 * TODO: change the name of the data structure / interface name / the
 * name of the first argument of the interfaces. (from *cpm* to your
 * own identification, see *UDF_TOKEN_SUBFIX* in your cfg file).
 */
/*
 * the driver's data structure, it's name must be *udf_drv_ds_***_t*, *** is
 * *UDF_TOKEN_SUBFIX*
 * if you are not satisfied with the name, please typedef it.
 */
typedef struct udf_drv_ds_cpm_t
{
	// TODO: your own implementation
	int a;
	char b;
	char c[100];

	// NOTE: don't delete follow 3 variable
	udf_kdrv_rep_t bh_rep;
	udf_kdrv_op_set_t bh_op_set;
	int slot;
	void * card_base_addr;
} cpm_drv_data_t;



/*
 * constructure for cpm drv ds
 * NOTE: it is a *ctor*, not *new*
 */
int udf_ctor_drv_ds_cpm_fn(
	cpm_drv_data_t * pData,	// the data you should initialize
	udf_kdrv_rep_t bh_rep,	// you need store it to op bh part
	const udf_kdrv_op_set_t * bh_op_set,	// you need store it to op bh part
	int slot,	// you can use it, it's better to store it.
	void * card_base_addr);
/*
 * destructure for cpm drv ds
 * NOTE: it is a *dtor*, not *delete*
 */
void udf_dtor_drv_ds_cpm_fn(cpm_drv_data_t *);


/*
 * handle interrupt.
 * NOTE: it will be issued when *read* in *user mode driver*, and be
 *       issued when *isr* in *kernel mode driver*.
 * return:
 * return the number of interrupts found, if *>0*, the interrupt will
 * be re-enabled, or some error occurred.
 */
int udf_int_handler_cpm_fn(cpm_drv_data_t *);

/*
 * read the result generated by the last interface above this interface, so your
 * result must be stored in some place can be found throuth the first argument.
 * a simple way is store the result in the structure pointed to by the first
 * argument.
 */
ssize_t udf_read_int_data_cpm_fn(cpm_drv_data_t *, void * buf, size_t count);


#ifdef __cplusplus
}
#endif

